# -*- coding: utf-8 -*-
"""

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jxHFn8hswqM5mfJ-_RzHBy_BNjZ4lXT6
"""

# 1 Mounting google drive
from google.colab import drive
drive.mount('/content/drive')

import math
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

drive_path = 'drive/My Drive/Colab Notebooks/Clustering/'

input_file_name = "blobs.txt"
#input_file_name = "moons.txt"
#input_file_name = "bisecting.txt"

#input_file_name = "test.txt"

input = open(drive_path+ input_file_name,"r")

points_arr = np.array([line.split() for line in input.readlines()], dtype='float64')

n = len(points_arr )
distance_matrix = [[-1 for i in range(0,n)] for j in range(0,n)]

cnt = 0

for i in range(0,n):
    for j in range(0,n):
        if distance_matrix[i][j] != -1:
            continue
        if i==j :
            distance_matrix[i][j] = float('inf')    
        else :
            distance_matrix[i][j] = distance_matrix[j][i] = np.sqrt(((points_arr[i][0] - points_arr[j][0])**2 + (points_arr[i][1] - points_arr[j][1])**2))
        
k = 4
kth_nei = []

i = 0
for i in range(0,n):
  kth_distance = sorted (distance_matrix[i])[k-1]
  kth_nei.append(kth_distance)
  #i = i+1

X = [i+1 for i in range(0, n)]
Y = sorted (kth_nei)

plt.plot(X,Y, label = "line 2", color = "r")
plt.xlabel('Points sorted According to distance of 4th nearest neighbour')
plt.ylabel('4th Nearest Neighbour Distance')
plt.title('DBSCAN Parameter ' +  input_file_name)
plt.show()

#dbscan

eps = 0.4
min_samples = 4
X = points_arr
#print(np.arange(len(X)))


def euclidean_distance(x1, x2):
    distance = 0
    for i in range(len(x1)):
        distance += pow((x1[i] - x2[i]), 2)
    return math.sqrt(distance)


def get_neighbors(sample_i):
      neighbors = []
      idxs = np.arange(len(X))
      for i, _sample in enumerate(X[idxs != sample_i]):
          distance = euclidean_distance(X[sample_i], _sample)
          if distance < eps:
            neighbors.append(i)
      return np.array(neighbors)


def expand_cluster(sample_i, neighbors):
        cluster = [sample_i]
        for neighbor_i in neighbors:
            if not neighbor_i in visited_samples:
                visited_samples.append(neighbor_i)
                #print(visited_samples)
                neighbors[neighbor_i] = get_neighbors(neighbor_i)
                if len(neighbors[neighbor_i]) >= min_samples:
                    expanded_cluster = expand_cluster(neighbor_i, neighbors)
                    cluster = cluster + expanded_cluster
                else:
                    cluster.append(neighbor_i)
        return cluster


def get_cluster_labels():
        labels = np.full(shape=X.shape[0], fill_value=len(clusters))
        for cluster_i, cluster in enumerate(clusters):
            for sample_i in cluster:
                labels[sample_i] = cluster_i
        return labels



def predict(X):
        clusters = []
        visited_samples = []
        neighbors = {}  
        n_samples = np.shape(X)[0]
        for sample_i in range(n_samples):
            if sample_i in visited_samples:
                continue
            neighbors[sample_i] = get_neighbors(sample_i)
            #print(sample_i, neighbors, visited_samples)
            if len(neighbors[sample_i]) >= min_samples:
                visited_samples.append(sample_i)
                new_cluster = expand_cluster(sample_i, neighbors)
                clusters.append(new_cluster)

        cluster_labels = get_cluster_labels()
        return cluster_labels

k_value = len((np.unique(predict(X))))
print (k_value)

#k means

def assignment(df, centroids):
    for i in centroids.keys():
        # sqrt((x1 - x2)^2 - (y1 - y2)^2)
        df['distance_from_{}'.format(i)] = (
            np.sqrt(
                (df['x'] - centroids[i][0]) ** 2
                + (df['y'] - centroids[i][1]) ** 2
            )
        )
    centroid_distance_cols = ['distance_from_{}'.format(i) for i in centroids.keys()]
    df['closest'] = df.loc[:, centroid_distance_cols].idxmin(axis=1)
    df['closest'] = df['closest'].map(lambda x: int(x.lstrip('distance_from_')))
    df['color'] = df['closest'].map(lambda x: colmap[x])
    return df


np.random.seed(42)
k = 2

x_min = (min(points_arr[:,0]))
y_min = (min(points_arr[:,1]))

x_max = (max(points_arr[:,0]))
y_max = (max(points_arr[:,1]))

centroids = {
   i+1: [np.random.uniform(x_min, x_max), np.random.uniform(x_min, y_max)]
   for i in range(k)
}

print (centroids)
plt.scatter(points_arr[:,0], points_arr[:,1])
colmap = {1: 'r', 2: 'g', 3: 'y', 4: 'k', 5: 'c', 6: 'm'}
for i in centroids.keys():
    plt.scatter(*centroids[i], color=colmap[i])

plt.show()

df = pd.DataFrame({
    'x': points_arr[:,0],
    'y': points_arr[:,1]
})

df = assignment(df, centroids)

def update(k):
    for i in centroids.keys():
        centroids[i][0] = np.mean(df[df['closest'] == i]['x'])
        centroids[i][1] = np.mean(df[df['closest'] == i]['y'])
    return k

centroids = update(centroids)

while True:
    closest_centroids = df['closest'].copy(deep=True)
    centroids = update(centroids)
    df = assignment(df, centroids)
    if closest_centroids.equals(df['closest']):
        break
        
plt.scatter(df['x'], df['y'], color=df['color'])
for i in centroids.keys():
    plt.scatter(*centroids[i], color=colmap[i])
plt.show()
